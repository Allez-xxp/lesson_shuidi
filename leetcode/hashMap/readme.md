# hashMap（散列表） 应用场景算法
1. 10万条，URL访问日志（Log）一万个用户，应用场景
    备忘录算法
    - 10万条URL 访问日志 按访问次数给URL排序？
    - 解决方法：要输出一个URL，排好序的
    / 3万条
    /detail/1221212 5k
    /detail/5555 5k
    /comments/12121 2.1k
    - 输出结果：input 日志数组['/','/detail/1221212','/detail/5555','/comments/12121']

2. 选择什么样的数据结构解决这个问题？
前端 JSON Object{ } -》 散列表（HashMap)：键值对，高级的数据结构，语言内置的（相比较js）
3. 算法实现这个数据结构
    - 接触过什么样的排序算法？
    1. 首先要做一次for循环 遍历一次，有10万条；url就是一个key,value 第一次就计为1，否则就加一
    一个字典，一个hashmap,在不同语言中叫法不一样。
    构建出：
    {
        '/': 30000,
        '/detail/1221212':5000,
        ...
    }
    - 散列表，什么叫散？
    2. 排序 怎么排？
    数值类型，排序算法（从大到小）
    排完后得到一个['url']排好序的

4. Word 有项功能：单词纠错
    - 错的单词下面会标红，怎么实现？
    将输入的单词与词典对比
    - 方法：
    建一个字典，在js中叫做json Object
    把易混错的单词做成一个key:value,为其纠错。
    - 为什么选择hashMap？
    dictionary hashmap的时间复杂度是O(1),这就是我们选择这种数据结构的原因。
    不需要遍历，只需要通过将输入值作为key去我们hashmap中找一下，就出来了

5. Hash Table 哈希表
    - 为key:value的访问提供了一个O(1)的时间复杂度
    - 两数相加
    一次O(n)开销后，形成一个hash table
    key：value

6. Hash Table的O(1)这种的访问在哪种更简单的数据结构中用过？
    - 数组中
    - 数组为什么可以实现O(1)的时间复杂度的访问？
    - 散列表的概念
    运动会，89个同学一起参与1000米跑步，记录成绩是用数组放置,每个同学身上贴一个参赛号码0..88
    成绩：[13,11,12...]这里面就散开来了。
    如果89个人全都聚在一起，想要快速区分某个人，用O(1)是不可能的
    大家都散开来，数组就是一个散表，散开来后每个人就是一个坑位，也就是数组的下标，就能通过下标快速找到比如40号存在哪里？
    时间复杂度是O(1),因为它不需要从第一个位置一直往后遍历n个位置，
    O（1）  start(0)+40偏移量--算法物理执行的本质，内存地址的计算
    

7. 散列表的概念  
他也是散开来，他是列作为下标也就是key,0它的查询是O(1)

8. 思考40号选手在数组中就是他的下标，下标是数值型的，hashmap中用key做下标
    - 希望查出来的不仅是40号这个号码，还有关于选手的其他信息 这里面的key比单纯的数值更有意义
    030340 加上班级号，表达出更多的含义，这样的话怎么实现O(1)呢？
    - hashmap是如何实现O(1)查询的？
    hashMap是基于数组的
    运动会 030340号码（散列表的表示）  40号(数组的表示)  在各个跑道散开的运动员身上的号码，这两个在最后的跑道上的占位上其实是同一个概念
    做一个列-》integer i 的散列处理函数
    物理上 key->计算出一个物理位置O(1),把值返回

9. 030340 如何反映出原来是40号位置？